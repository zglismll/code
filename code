有效数字 leetcode 65

判断两个double类型数字是否相等 使用|(a-b)|<0.000000001
两数之和 哈希  双指针
ListNode* dummy ListNode* next
next = dummy  用next代dummy变化，返回dummy->next;
string p = p+'a';
不能在声明时运用
string p;
p = p+'a';

链表
最后需要加->next = nullptr;
链表封装  (重组一个链表,Notice:最后需要加->next = nullptr;否则会出现循环)
归并排序常见格式：
if(a==b)
return ;
else
{ int m = (a+b)/2;
   merge(a,m);
   merge(m+1,b);
}

sort(A.begin(),A.end(),cmp);
cmp加static
static int cmp

链表归并排序 
快慢指针；注意区间长度为2个节点的情况
每次剖开加nullptr;


区间相交情况很多，先找不相交。

LIS nlogn解法
leetcode 300


数字转字符
while(num)
{
}
注意num一开始为0不进入循环情况；
注意输出“00000”若为数字输出应改为“0”；


(n&(n-1)) 二进制最右边1变为0，计算二进制中1个数
如果(n&(n-1))==0 这个数是2的幂次。(非负）

堆排序
n/2-1 堆末父节点
0 堆首节点
2*i+1 左节点
2*i+2 右节点


优先队列
排序函数重载

leetcode 74
二分法

滑动窗口

manacher
len[i]表示最左边相同字符和中心处的距离。(中心处在内)
max 表示最左边第一个和中心不为回文串的下标。


二叉树重建
二叉搜索树



2的幂次 （非负判断）

（位运算 括号 注意优先级）


股票买卖（四种dp）


multiset 
erase(val)  删除所有值是val 值
erase(lower_bound(val)) 删除第一个大于等于的值 （最多删除一个)

set<int> W;
W.lower_bound(p); 返回找到的下标 注意下标越界的处理。
W.erase（p)
W.erase(W.lower_bound(p));
